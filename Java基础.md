## Java基础

### 基础概念与常识

#### Java语言特点

1. 面向对象（封装、继承、多态）；
2. Java虚拟机能实现平台无关性；
3. 垃圾回收机制；

#### JVM、JDK和JRE

1.JVM是运行字节码的虚拟机，对不同系统有特定实现，目的是针对相同字节码，给出相同的结果。

从程序到源代码运行步骤：.java===编译====>.class===JVM===>机器可执行二进制码。

2.JRE：Java运行环境。包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。

3.JDK（ Java Development Kit ）：Java开发环境。包含JRE拥有的一切

![image-20210304184411282](D:\GithubRepository\DailyRecordOfJava\Java基础.assets\image-20210304184411282.png)

#### Java和C++异同

同：都是面向对象；

异：Java不支持指针访问内存，更安全；Java 的类是单继承的，C++ 支持多重继承，Java接口可多继承；Java有垃圾回收机制GC；



### Java语法

#### 字符型常量和字符串常量

1. 含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)
2. 占内存大小：字符常量只占 2 个字节; 字符串常量占若干个字节 (**注意： char 在 Java 中占两个字节**)；
3. 形式上: 字符常量是单引号引起的一个字符; 字符串常量是双引号引起的 0 个或若干个字符。

#### 注释

Java 中的注释有三种：

1. 单行注释
2. 多行注释
3. 文档注释。

#### 泛型

JDK5.0引入的新特性，

泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。

#### ==和equals()区别

==：基本数据类型比较的是值，引用数据类型比较的是内存地址；

equals()：存在于Object类中，作用是判断两个对象是否相等；

```java
public boolean equals(Object obj) {
     return (this == obj);
}
```

equals两种情况：

1. 类没覆盖重写。默认调用Object类中equals()方法，等价于使用==；
2. 覆盖重写。一般重写判断两个对象内容相等。

#### hashCode()与equals()

hashCode()为native方法；

```java
public native int hashCode();
```

两个对象相等时，其hashcode()也相等。重写equals()方法后，重写定义了相等，需要重写hashCode()，且equals()用道的field，hashCode()尽量也用到。

#### 深拷贝、浅拷贝

1. **浅拷贝**：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。
2. **深拷贝**：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。

### 基本数据类型

#### 基本数据类型、大小、包装类

| 基本类型 | 包装类    | 位数 | 字节 | 默认值  |
| -------- | --------- | ---- | ---- | ------- |
| int      | Integer   | 32   | 4    | 0       |
| short    | Short     | 16   | 2    | 0       |
| long     | Long      | 64   | 8    | 0L      |
| byte     | Byte      | 8    | 1    | 0       |
| char     | Character | 16   | 2    | 'u0000' |
| float    | Float     | 32   | 4    | 0f      |
| double   | Double    | 64   | 8    | 0d      |
| boolean  | Boolean   | 1    |      | false   |

#### 自动装箱、自动拆箱

装箱：将基本类型用它们对应的引用类型包装起来；

拆箱：将包装类型转换为基本数据类型；

#### 8种基本数据类型的包装类和常量池￥





### 面向对象

面向对象学习的三条主线：

1.Java类及类的成员：属性、方法、构造器；代码块、内部类；

2.面向对象的大特征：封装性、继承性、多态性、(抽象性)

3.其它关键字：this、super、static、final、abstract、interface、package、import等



**面向对象和面向过程**

面向过程POP：强调的是功能行为，以函数为最小单位，考虑怎么做。

面向对象OOP：强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。（更适合规模较大的问题）

区别：面向对象面向对象有封装、继承、多态性的特性，易维护、易复用、易扩展，可以设计出低耦合的系统。面向对象性能比面向过程低。

![image-20210305153616243](D:\GithubRepository\DailyRecordOfJava\Java基础.assets\image-20210305153616243.png)

#### 类与对象

类：对一类事物的描述，是抽象的、概念上的定义
对象：是实际存在的该类事物的每个个体，因而也称为实例(instance)

二者的关系：对象，是由类new出来的，派生出来的。对象引用指向对象实例，对象实例在堆内存中，对象引用存放在栈内存中。

匿名对象:我们创建的对象，没显式的赋给一个变量名。即为匿名对象
特点：匿名对象只能调用一次。



**JVM内存结构**

编译完源程序以后，生成一个或多个字节码文件。
我们使用JVM中的类的加载器和解释器对生成的字节码文件进行解释运行。意味着，需要将字节码文件对应的类加载到内存中，涉及到内存解析。

![image-20210305154659749](D:\GithubRepository\DailyRecordOfJava\Java基础.assets\image-20210305154659749.png)

《JVM规范》

虚拟机栈，即为平时提到的栈结构。我们将局部变量存储在栈结构中
堆，我们将new出来的结构（比如：数组、对象）加载在对空间中。补充：对象的属性（非static的）加载在堆空间中。
方法区：类的加载信息、常量池、静态域



代码块：

#### 属性

属性 = 成员变量 = field = 域、字段

**属性  vs  局部变量**

同：定义格式；先声明，后使用；

异：

1. 定义位置不同；
2. 属性可使用权限修饰符；
3. 局部变量没有默认初始化值，需要显式赋值；
4. 内存种加载位置不同。属性加载到堆空间中（非static）；局部变量加载到栈空间；

#### 方法

方法 = 成员方法 = 函数 = method

方法的声明

```java
//权限修饰符  返回值类型  方法名(形参列表){
//  		方法体
//}
```

说明：

1. 关于权限修饰符。Java规定的4种权限修饰符：private、public（默认）、缺省、protected
2. 返回值。若有返回值，在方法声明时，制定返回值类型，方法中，“return 数据”；若没有返回值，不需要使用return，或“return;”，表示方法结束。
3. 形参列表。可定义多个。**Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。**

体现封装性，“高内聚，低耦合”。

**重载与重写**

重载：同一个方法根据不同的形参列表，做出不同的处理；

重写：子类方法覆盖父类方法。

**递归**

一个方法体内调用它自身。

#### 构造器

作用：创建对象；初始化对象信息；

使用说明：

1.如果没显式的定义类的构造器的话，则系统默认提供一个空参的构造器

2.定义构造器的格式：权限修饰符  类名(形参列表){}；无返回值；

3.一个类中定义的多个构造器，彼此构成重载

4.一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器

5.一个类中，至少会有一个构造器。



所谓**JavaBean**，是指符合如下标准的Java类：类是公共的；一个无参的公共构造器；属性，且对应的get、set方法；

**不做事没有参数的构造方法作用**：子程序在执行构造方法之前，会调用父类中“没有参数的构造方法”。如果父类只定义有参数的构造方法，而子类没有用super()调用父类特定构造方法，则编译时报错，因为父类缺少“没有参数的构造方法”。

#### 三大特性

封装性

封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。

权限修饰符：权限从小到大顺序为：private <  缺省 < protected < public

4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类。修饰类的话，只能使用：缺省、public。



继承性

继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。

优点：减少了代码的冗余，提高了代码的复用性；便于功能的扩展；为之后多态性的使用，提供了前提；

子类继承父类后的不同：一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法。（特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私的结构。只因为封装性的影响，使得子类不能直接调用父类的结构而已。）

子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。

**java.lang.Object类的理解**

1. 如果我们没显式的声明一个类的父类的话，则此类继承于java.lang.Object类
2. 所的java类（除java.lang.Object类之外都直接或间接的继承于java.lang.Object类
3. 意味着，所的java类具有java.lang.Object类声明的功能。



多态性

可以理解为一个事物的多种形态。父类的引用指向子类的对象（或子类的对象赋给父类的引用）。

```java
Person p = new Man();
Object obj = new Date();
```

有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。

编译，看左边；运行，看右边。

多态不适用于属性。属性没有重写；

**为什么多态调用方法必须在运行时才能确定**：编译期间不会分配内存空间，不会创建实例对象，所以无法调用子类方法。

**向上转型与向下转型**

向上转型：多态

向下转型：调用子类的属性和方法；强转前用instanceof判断；

![image-20210305161907647](D:\GithubRepository\DailyRecordOfJava\Java基础.assets\image-20210305161907647.png)





#### 关键字、修饰符

**this**：当前对象。可调用属性、方法、构造器；在方法和构造器中，形参和类的属性同名时，使用较多。

this调用构造器：
我们在类的构造器中，可以显式的使用"this(形参列表)"方式，调用本类中指定的其他构造器
构造器中不能通过"this(形参列表)"方式调用自己
如果一个类中有n个构造器，则最多有 n - 1构造器中使用了"this(形参列表)"
规定："this(形参列表)"必须声明在当前构造器的首行
构造器内部，最多只能声明一个"this(形参列表)"，用来调用其他的构造器

**super**：父类的。

static：静态的。

final：最终的。

abstract：抽象的。

interface：接口。



#### 接口

#### 内部类



### 常用类

#### String

java.lang.String类的使用
1.概述
String:字符串，使用一对""引起来表示。
1.String声明为final的，不可被继承
2.String实现了Serializable接口：表示字符串是支持序列化的。
        实现了Comparable接口：表示String可以比较大小
3.String内部定义了final char[] value用于存储字符串数据
4.通过**字面量**的方式（区别于new给一个字符串赋值，此时的字符串值声明在字符串常量池中)。
5.字符串常量池中是不会存储相同内容(使用String类的equals()比较，返回true)的字符串的。



2.String的不可变性
2.1 说明
1.当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。
2.当对现的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。
3.当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。

3.String实例化的不同方式
3.1 方式说明

```java
String s1 = "javaEE";//方式一：通过字面量定义的方式

String s3 = new String("javaEE");//方式二：通过new + 构造器的方式
```

4. 字符串拼接方式赋值的对比
   4.1 说明
   1.常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。
   2.只要**其中一个是变量**，结果就**在堆中**。
   3.如果拼接的结果调用intern()方法，返回值就在常量池中。

##### 底层存储

栈、堆、常量池

![image-20210227195714077](D:\GithubRepository\DailyRecordOfJava\Java基础.assets\image-20210227195714077.png)

##### String和其它类型相互转换

String --> 基本数据类型、包装类：调用包装类的静态方法：parseXxx(str)
    基本数据类型、包装类 --> String:调用String重载的valueOf(xxx)

6.2 与字符数组之间的转换
String --> char[]:调用String的toCharArray()
char[] --> String:调用String的构造器

##### String、StringBuffer、StringBuilder三者的对比

String:不可变的字符序列；底层使用char[]存储
StringBuffer:可变的字符序列；线程安全的，效率低；底层使用char[]存储
StringBuilder:可变的字符序列；jdk5.0新增的，线程不安全的，效率高；底层使用char[]存储



源码分析

```java
    String str = new String();//char[] value = new char[0];
    String str1 = new String("abc");//char[] value = new char[]{'a','b','c'};

    StringBuffer sb1 = new StringBuffer();//char[] value = new char[16];底层创建了一个长度是16的数组。
    System.out.println(sb1.length());//
    sb1.append('a');//value[0] = 'a';
    sb1.append('b');//value[1] = 'b';

    StringBuffer sb2 = new StringBuffer("abc");//char[] value = new char["abc".length() + 16];
```

问题1. System.out.println(sb2.length());//3
问题2. 扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。
             默认情况下，扩容为原来容量的2倍 + 2，同时将原有数组中的元素复制到新的数组中。

指导意义：开发中建议大家使用：StringBuffer(int capacity) 或 StringBuilder(int capacity)

3.对比String、StringBuffer、StringBuilder三者的执行效率
从高到低排列：StringBuilder > StringBuffer > String;

#### 枚举类型



### 反射

### 异常

### 参考文献

《Java核心技术》

https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_1-java-%e5%9f%ba%e6%9c%ac%e5%8a%9f