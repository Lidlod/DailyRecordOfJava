* [Java虚拟机](#java虚拟机)
  * [运行时数据区域](#运行时数据区域)
  * [内存模型](#内存模型)
  * [抛出OutOfMemoryError（OOM）](#抛出outofmemoryerroroom)
  * [垃圾回收](#垃圾回收)
    * [判断死亡的方法](#判断死亡的方法)
  * [参考文献](#参考文献)



## Java虚拟机

JVM/GC：垃圾回收、OOM、判



断死亡方法、

### 运行时数据区域

<a href="#head">`点这里从头再读一遍`</a>

![image-20210306122030665](D:\GithubRepository\DailyRecordOfJava\Java虚拟机.assets\image-20210306122030665.png)

**程序计数器**：字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。程序计数器私有主要是为了**线程切换后能恢复到正确的执行位置**。

**虚拟机栈：** 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。

**本地方法栈：** 和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

为了**保证线程中的局部变量不被别的线程访问到**，虚拟机栈和本地方法栈是线程私有的。

和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。



### 内存模型

栈：每个线程有一个栈区（线程私有），栈中只保存基本数据类型和自定义对象的引用。对象放在堆区；

堆：存储对象。被所有线程所共享，堆中数据由垃圾回收负责（GC堆）

方法静态区：被所有线程共享，存储class和static变量；元素唯一，类如String；

多线程共享的区域？堆、方法区；

和垃圾回收相关？堆；



### 抛出OutOfMemoryError（OOM）

OOM：Out Of Memory，内存溢出；

原因：分配内存少；GC跟不上分配新对象的速度；

常见OOM：java堆内存溢出、java永久代溢出、JAVA虚拟机栈溢出；



内存泄漏：申请完没有释放，虚拟机不能再次使用；Java中也可能出现

详见：https://www.cnblogs.com/thinkvenus/p/6805495.html

### 垃圾回收

什么是GC？为什么要用GC？

垃圾指程序当中，没有任何指针指向的对象；不GC，可能导致内存溢出；

垃圾回收针对堆和方法区进行，方法区可回收可不回收；



#### 判断死亡的方法

1.添加引用计数器（不采用）。对象添加一个引用时，加1，引用失效减1，引用计数为0对象被回收。当对象出现循环引用，会导致计数器永不为0。

2.可达性分析算法。





### 参考文献

尚硅谷 JVM：135什么时JC，157内存溢出分析

cyc2018

《深入理解Java虚拟机》