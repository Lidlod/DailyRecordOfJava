* [Java虚拟机](#java虚拟机)
  * [运行时数据区域](#运行时数据区域)
  * [内存模型](#内存模型)
  * [抛出OutOfMemoryError（OOM）](#抛出outofmemoryerroroom)
  * [垃圾回收](#垃圾回收)
    * [判断死亡的方法](#判断死亡的方法)
  * [参考文献](#参考文献)



## Java虚拟机

JVM/GC：垃圾回收、OOM、判

### C++和Java

C++程序员：有每个对象的“所有权”，又担负维护责任；

Java程序员：把内存控制权交给JVM，一但出现问题，排查困难；



### 运行时数据区域

![image-20210306122030665](D:\GithubRepository\DailyRecordOfJava\1-基础\Java虚拟机.assets\image-20210306122030665.png)

**程序计数器**：字节码行号指令器，实现流程控制；多线程切换复位；

> 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。程序计数器私有主要是为了**线程切换后能恢复到正确的执行位置**。

**虚拟机栈：**存放编译时可知基本数据类型，对象引用。方法调用压栈；

> 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。

**本地方法栈：** 提供native方法；

> 和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

> 为了**保证线程中的局部变量不被别的线程访问到**，虚拟机栈和本地方法栈是线程私有的。

堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

**堆**：存放对象实例；垃圾回收器管理的主要区域，也叫GC堆；

**方法区**：存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

**运行时常量池**：方法区的一部分。





### 抛出OutOfMemoryError（OOM）

**StackOverFlowError**：

若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。

**OutOfMemoryError**：

若 Java 虚拟机堆中没有空闲内存，并且垃圾回收器也无法提供更多内存的话。就会抛出 OutOfMemoryError 错误。

 当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。

假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发。

错误。(和本机物理内存无关，和你配置的内存大小有关！)



OOM：Out Of Memory，内存溢出；

原因：分配内存少；GC跟不上分配新对象的速度；

常见OOM：java堆内存溢出、java永久代溢出、JAVA虚拟机栈溢出；



内存泄漏：申请完没有释放，虚拟机不能再次使用；Java中也可能出现

详见：https://www.cnblogs.com/thinkvenus/p/6805495.html

### 垃圾回收

什么是GC？为什么要用GC？

垃圾指程序当中，没有任何指针指向的对象；不GC，可能导致内存溢出；

垃圾回收针对堆和方法区进行，方法区可回收可不回收；



#### 判断死亡的方法

1.添加引用计数器（不采用）。对象添加一个引用时，加1，引用失效减1，引用计数为0对象被回收。当对象出现循环引用，会导致计数器永不为0。

2.可达性分析算法。





### 参考资料

cyc2018

JavaGuide

《深入理解Java虚拟机》