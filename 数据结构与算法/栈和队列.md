## 栈和队列

### 栈

#### 用链表实现栈

```java
public class Stack<T> implements Iterable<T>{
    private Node head;
    private int N;

    private  class Node{
        public T item;
        public Node next;
        public Node(T item,Node next){
            this.item = item;
            this.next = next;
        }
    }
    
public Stack(){
        this.head = new Node(null,null);
        this.N = 0;
    }

    // 判断当前栈中元素是否为0；
    public boolean isEmpty(){
        return N == 0;
    }

    // 获取栈中元素的个数
    public int size(){
        return N;
    }

    // 把t元素压入栈
    public void push(T t){
        Node temp = new Node(t,head.next);
        head.next = temp;
        N++;
    }

    // 弹出栈顶元素
    public T pop(){
        if(N==0){
            return null;
        }
        T temp = head.next.item;
        head.next = head.next.next;
        N--;
        return temp;
    }
}
```



#### 括号匹配问题

```java
// 判断str中的括号是否匹配
public boolean isMatch(String str){
    // 创建一个栈；
    Stack<String> leftBrackets = new Stack<>();
    // 遍历字符串
    // 若为（，压栈；若为），弹栈
    for(int i=0;i<str.length();i++){
        char temp = str.charAt(i);
        if(temp == '('){
            leftBrackets.push(String.valueOf(temp));
        }else if(temp == ')'){
            if(leftBrackets.pop() == null){
                return false;
            }
        }
    }
    // 遍历完后，栈中应该无元素
    if(leftBrackets.size()>0){
        return false;
    }else{
        return true;
    }
}
```

### 队列

用数据实现

```java
public class Queue<T> implements Iterable<T>{
    private Node head;
    private Node last;
    private int N;

    private class Node{
        public T item;
        public Node next;

        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }
    }

    public Queue() {
        this.head = new Node(null,null);
        this.last = null;
        this.N = 0;
    }
    // 向队列中插入元素t；向尾部插入元素
    public void enqueue(T t){
        Node temp = new Node(t,null);
        if(isEmpty()){
            head.next = temp;
        }else{
            last.next = temp;

        }
        last = temp;
        N++;
    }
    // 从队列中拿出一个元素
    public T dequeue(){
        // 拿出head后的结点
        if(isEmpty()){
            return null;
        }
        Node nextNode = head.next;
        T res = nextNode.item;
        if(nextNode.next == null){
            last = null;
        }
        head.next = nextNode.next;
        N--;
        return res;
    }
}
```



### 参考资料

[代码随想录](https://github.com/Lidlod/DailyRecordOfJava/blob/main/%E5%A4%9A%E7%BA%BF%E7%A8%8B.md)